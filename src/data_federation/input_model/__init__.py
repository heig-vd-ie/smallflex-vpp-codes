"""
Automatically generated by scripts from the changes in raw_data/models.
"""
from __future__ import annotations
from typing import TypedDict, Unpack
from dataclasses import dataclass, field, replace
import os
import tqdm
import duckdb
import polars as pl
import patito as pt

from data_federation import input_model
from data_federation.input_model.humidity import Humidity
from data_federation.input_model.basin_height import BasinHeight
from data_federation.input_model.hydro_power_plant import HydroPowerPlant
from data_federation.input_model.ssd import Ssd
from data_federation.input_model.precipitation import Precipitation
from data_federation.input_model.market_price import MarketPrice
from data_federation.input_model.power_plant_state import PowerPlantState
from data_federation.input_model.basin_height_volume_table import BasinHeightVolumeTable
from data_federation.input_model.water_basin import WaterBasin
from data_federation.input_model.irradiation import Irradiation
from data_federation.input_model.hydro_power_performance_table import HydroPowerPerformanceTable
from data_federation.input_model.resource import Resource
from data_federation.input_model.temperature import Temperature
from data_federation.input_model.wind import Wind
from data_federation.input_model.discharge_flow import DischargeFlow

from utility.general_function import snake_to_camel

class SmallFlexPolarsModel(TypedDict, total=False):
    humidity: pl.DataFrame
    basin_height: pl.DataFrame
    hydro_power_plant: pl.DataFrame
    ssd: pl.DataFrame
    precipitation: pl.DataFrame
    market_price: pl.DataFrame
    power_plant_state: pl.DataFrame
    basin_height_volume_table: pl.DataFrame
    water_basin: pl.DataFrame
    irradiation: pl.DataFrame
    hydro_power_performance_table: pl.DataFrame
    resource: pl.DataFrame
    temperature: pl.DataFrame
    wind: pl.DataFrame
    discharge_flow: pl.DataFrame

class SmallFlexInputModel(TypedDict, total=False):
    humidity: pt.DataFrame[Humidity]
    basin_height: pt.DataFrame[BasinHeight]
    hydro_power_plant: pt.DataFrame[HydroPowerPlant]
    ssd: pt.DataFrame[Ssd]
    precipitation: pt.DataFrame[Precipitation]
    market_price: pt.DataFrame[MarketPrice]
    power_plant_state: pt.DataFrame[PowerPlantState]
    basin_height_volume_table: pt.DataFrame[BasinHeightVolumeTable]
    water_basin: pt.DataFrame[WaterBasin]
    irradiation: pt.DataFrame[Irradiation]
    hydro_power_performance_table: pt.DataFrame[HydroPowerPerformanceTable]
    resource: pt.DataFrame[Resource]
    temperature: pt.DataFrame[Temperature]
    wind: pt.DataFrame[Wind]
    discharge_flow: pt.DataFrame[DischargeFlow]

def validate(**kwargs: Unpack[SmallFlexInputModel]) -> None:
    for df in kwargs.values():
        df.validate() # type: ignore

@dataclass(frozen=True)
class SmallflexInputSchema:
    humidity: pt.DataFrame[Humidity] = field(default_factory=lambda: Humidity.DataFrame(schema=Humidity.columns).cast())
    basin_height: pt.DataFrame[BasinHeight] = field(default_factory=lambda: BasinHeight.DataFrame(schema=BasinHeight.columns).cast())
    hydro_power_plant: pt.DataFrame[HydroPowerPlant] = field(default_factory=lambda: HydroPowerPlant.DataFrame(schema=HydroPowerPlant.columns).cast())
    ssd: pt.DataFrame[Ssd] = field(default_factory=lambda: Ssd.DataFrame(schema=Ssd.columns).cast())
    precipitation: pt.DataFrame[Precipitation] = field(default_factory=lambda: Precipitation.DataFrame(schema=Precipitation.columns).cast())
    market_price: pt.DataFrame[MarketPrice] = field(default_factory=lambda: MarketPrice.DataFrame(schema=MarketPrice.columns).cast())
    power_plant_state: pt.DataFrame[PowerPlantState] = field(default_factory=lambda: PowerPlantState.DataFrame(schema=PowerPlantState.columns).cast())
    basin_height_volume_table: pt.DataFrame[BasinHeightVolumeTable] = field(default_factory=lambda: BasinHeightVolumeTable.DataFrame(schema=BasinHeightVolumeTable.columns).cast())
    water_basin: pt.DataFrame[WaterBasin] = field(default_factory=lambda: WaterBasin.DataFrame(schema=WaterBasin.columns).cast())
    irradiation: pt.DataFrame[Irradiation] = field(default_factory=lambda: Irradiation.DataFrame(schema=Irradiation.columns).cast())
    hydro_power_performance_table: pt.DataFrame[HydroPowerPerformanceTable] = field(default_factory=lambda: HydroPowerPerformanceTable.DataFrame(schema=HydroPowerPerformanceTable.columns).cast())
    resource: pt.DataFrame[Resource] = field(default_factory=lambda: Resource.DataFrame(schema=Resource.columns).cast())
    temperature: pt.DataFrame[Temperature] = field(default_factory=lambda: Temperature.DataFrame(schema=Temperature.columns).cast())
    wind: pt.DataFrame[Wind] = field(default_factory=lambda: Wind.DataFrame(schema=Wind.columns).cast())
    discharge_flow: pt.DataFrame[DischargeFlow] = field(default_factory=lambda: DischargeFlow.DataFrame(schema=DischargeFlow.columns).cast())

    def __post_init__(self):
        validate(**self.__dict__)

    def add_table(self,  **kwargs: Unpack[SmallFlexPolarsModel]) -> SmallflexInputSchema:
        new_kwargs: SmallFlexInputModel = self.cast_to_schema(**kwargs)
        validate(**new_kwargs)
        return replace(self, **new_kwargs)
    
    def cast_to_schema(self, **kwargs: Unpack[SmallFlexPolarsModel]) -> SmallFlexInputModel:
        new_kwargs: SmallFlexInputModel = {}
        for table_name, pl_table in kwargs.items():
            if not isinstance(pl_table, pl.DataFrame):
                raise ValueError(f"Table {table_name} is not a valid DataFrame")
            if table_name not in self.__dict__.keys():
                raise ValueError(f"{table_name} is not a valid name")
            
            pt_table: pt.DataFrame = getattr(self, table_name)
            col_list: list[str] = list(set(pl_table.columns).intersection(set(pt_table.columns)))
            
            new_table: pl.DataFrame = pl.concat([pt_table, pl_table.select(col_list)], how="diagonal_relaxed")

            new_kwargs[table_name] = pt.DataFrame(new_table)\
                .set_model(getattr(input_model, snake_to_camel(table_name)))\
                .fill_null(strategy="defaults").cast()
        return new_kwargs

    def schema_to_duckdb(self, file_path: str):
        if os.path.exists(file_path):
            os.remove(file_path)
        with duckdb.connect(file_path) as con:
            for table_name, table_pl in tqdm.tqdm(self.__dict__.items(), desc="Save raw data into duckdb file", ncols=150):
                query = f"CREATE TABLE {table_name} AS SELECT * FROM table_pl"
                con.execute(query)