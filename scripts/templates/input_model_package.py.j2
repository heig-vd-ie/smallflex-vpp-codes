"""
Automatically generated by scripts from the changes in raw_data/models.
"""
from __future__ import annotations
from typing import TypedDict, Unpack
from dataclasses import dataclass, field, replace
import os
import tqdm
import duckdb
import polars as pl
import patito as pt

from data_federation import input_model
{%- for m in models_list %}
from data_federation.input_model.{{ m.filename }} import {{ m.name }}
{%- endfor %}

from utility.general_function import snake_to_camel, build_non_existing_dirs

class SmallFlexPolarsModel(TypedDict, total=False):
    {%- for m in models_list %}
    {{ m.filename }}: pl.DataFrame
    {%- endfor %}

class SmallFlexInputModel(TypedDict, total=False):
    {%- for m in models_list %}
    {{ m.filename }}: pt.DataFrame[{{ m.name }}]
    {%- endfor %}

def validate(**kwargs: Unpack[SmallFlexInputModel]) -> None:
    for df in kwargs.values():
        df.validate() # type: ignore

@dataclass(frozen=True)
class SmallflexInputSchema:
    {%- for m in models_list %}
    {{ m.filename }}: pt.DataFrame[{{ m.name }}] = field(default_factory=lambda: {{ m.name }}.DataFrame(schema={{ m.name }}.columns).cast())
    {%- endfor %}

    def __post_init__(self):
        validate(**self.__dict__)

    def add_table(self,  **kwargs: Unpack[SmallFlexPolarsModel]) -> SmallflexInputSchema:
        new_kwargs: SmallFlexInputModel = self.cast_to_schema(**kwargs)
        validate(**new_kwargs)
        return replace(self, **new_kwargs)
    
    def cast_to_schema(self, **kwargs: Unpack[SmallFlexPolarsModel]) -> SmallFlexInputModel:
        new_kwargs: SmallFlexInputModel = {}
        for table_name, pl_table in kwargs.items():
            if not isinstance(pl_table, pl.DataFrame):
                raise ValueError(f"Table {table_name} is not a valid DataFrame")
            if table_name not in self.__dict__.keys():
                raise ValueError(f"{table_name} is not a valid name")
            
            pt_table: pt.DataFrame = getattr(self, table_name)
            col_list: list[str] = list(set(pl_table.columns).intersection(set(pt_table.columns)))
            
            new_table: pl.DataFrame = pl.concat([pt_table, pl_table.select(col_list)], how="diagonal_relaxed")

            new_kwargs[table_name] = pt.DataFrame(new_table)\
                .set_model(getattr(input_model, snake_to_camel(table_name)))\
                .fill_null(strategy="defaults").cast()
        return new_kwargs

    def schema_to_duckdb(self, file_path: str):
        build_non_existing_dirs(file_path)
        if os.path.exists(file_path):
            os.remove(file_path)
        with duckdb.connect(file_path) as con:
            for table_name, table_pl in tqdm.tqdm(self.__dict__.items(), desc="Save raw data into duckdb file", ncols=150):
                query = f"CREATE TABLE {table_name} AS SELECT * FROM table_pl"
                con.execute(query)

    def duckdb_to_schema(self, file_path: str) -> SmallflexInputSchema:
        schema_dict: dict[str, pt.Model.DataFrame] = {} # type: ignore
        pbar = tqdm.tqdm(
            total=1, ncols=150, desc="Read and validate tables from {} file".format(os.path.basename(file_path)))
        with pbar:
            with duckdb.connect(database=file_path) as con:
                query = "SELECT table_name FROM information_schema.tables WHERE table_schema = 'main'"
                for table_name in con.execute(query).fetchall():
                    query: str = f"SELECT * FROM {table_name[0]}"
                    schema_dict[table_name[0]] = con.execute(query).pl()
        return self.add_table(**schema_dict)